#### CSR

> 渲染工作主要在客户端进行

##### CSR 中获取数据的方法如下：

1.  通过`useEffect、fetch`来实现
2.  通过\`useSWR\` 等方法来实现

#### &#x20;SSR

> 渲染工作，有一部分在服务端进行，有一部分在客户端进行
>
> 服务端生成对应的HTML 返回 给客户端，此时页面无法响应点击事件
>
> 服务端同时还会加载打包好的客户端组件代码，这样子就可以响应点击事件了
>
> 关键方法，hydrateRoot 与renderToString 方法
>
> 生成HTML的过程中，服务端组件要要通过`renderToString`渲染一次组件，加载打包好的客户端组件代码的时候，会通过 `createRoot("XX").render()`函数再渲染一次，因此会渲染两次。此时，可以将客户端的render函数改成`hydrateRoot`方法，这个方法可以进行水合，保证组件只渲染一次

#### SSG

> SSG 是静态站点生成，就是可以在构建阶段，将页面生成HTML文件，以便加快访问速度。HTML文件可以使用CDN 缓存，可以加快访问的速度，提高用户体验和页面性能。

##### &#x20;获取动态数据的方法

> 在page Router,在比较低版本的浏览器中，可以使用如下函数来实现

*   `getStaticPaths()`
    > 为动态路由（如 `[id].js`）指定需要预渲染的路由参数（如 `id: 1, 2`）

*   `getServerSideProps()`

    > `getServerSideProps` 是在每次请求的时候被调用，`getStaticProps` 在每次构建的时候

*   `getStaticProps()`
    > 为页面（包括静态 / 动态路由）获取预渲染数据，返回 props 给页面组件
    > 在App Router 中，可以直接使用

*   `generateStaticParams()`
    > 更简洁，fallback 行为通过路由配置

#### ISR

> **增量静态再生（ISR）** 允许你在构建站点后，增量地更新静态页面，而无需重新构建整个网站。这结合了静态站点生成（SSG）的性能优势和服务器端渲染（SSR）的动态性

ISR 是在SSG的基础上，增加了更新数据的部分。

核心原理如下：

1.  先在构建时候，静态生成部分页面（类似于SSG）
2.  当页面被访问或者到达指定时间后，Next.js 会在后台重新生成页面（增量更新），确保内容新鲜度
3.  未生成的页面任然使用缓存的静态版本

> Next V14 中 基础用法：
>
> 通过 `fetch` 函数的 `next: { revalidate: 秒数 }` 选项，为数据设置缓存有效期

按需重新生成，可以使用`revalidatePath`、`revalidateTag`

> 这两个方法可以主动触动页面的重新生成

#### RSC

>

