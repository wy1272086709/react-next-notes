*   封装异步逻辑

> 封装一个useAsync,传递异步逻辑.

```php
import { useState, useCallback } from "react";

export default (asyncFunction) => {
  // 设置三个异步逻辑相关的 state
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  // 定义一个 callback 用于执行异步逻辑
  const execute = useCallback(() => {
    // 请求开始时，设置 loading 为 true，清除已有数据和 error 状态
    setLoading(true);
    setData(null);
    setError(null);
    return asyncFunction()
      .then((response) => {
        // 请求成功时，将数据写进 state，设置 loading 为 false
        setData(response);
        setLoading(false);
      })
      .catch((err) => {
          setError(err);
      })
      .finally((error) => {
        // 请求失败时，设置 loading 为 false，并设置错误状态
        setLoading(false);
      });
  }, [asyncFunction]);

  return { execute, loading, data, error };
};
```

*   调用异用逻辑

> 当点击事件发生后,获取对应的state中的变量

```php
import useAsync from "./useAsync";

export default function UserList() {
  // 通过 useAsync 这个函数，只需要提供异步逻辑的实现
  const { execute: fetchUsers, data: users, loading, error } = useAsync(
    async () => {
      const res = await fetch("https://reqres.in/api/users/");
      const json = await res.json();
      return json.data;
    },
  );

  return (
    <div className="user-list">
      <h1>Use Async Sample</h1>

      <button onClick={fetchUsers} disabled={loading}>
        {loading ? "Loading..." : "Show Users"}
      </button>
      {error && <div style={{ color: "red" }}>Failed: {String(error)}</div>}
      <br />
      <ul>
        {users &&
          users.length > 0 &&
          users.map((user) => {
            return <li key={user.id}>{user.first_name}</li>;
          })}
      </ul>
    </div>
  );
}
```

*   自定义useForm 逻辑,可以用于表单验证,显示错误信息,以及响应表单输入.

> useForm 代码如下:

```javascript
import { useState, useMemo, useCallback } from "react";

const useForm = (initialValues = {}, validators) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});

  const setFieldValue = useCallback(
    (name, value) => {
      setValues((values) => ({
        ...values,
        [name]: value,
      }));

      if (validators[name]) {
        const errMsg = validators[name](value);
        setErrors((errors) => ({
          ...errors,
          [name]: errMsg || null,
        }));
      }
    },
    [validators],
  );

  return { values, errors, setFieldValue };
};
```

*   调用form 表单的例子

```php
export default () => {
  const validators = useMemo(() => {
    return {
      name: (value) => {
        if (value.length < 2) return "Name length should be no less than 2.";
        return null;
      },
      email: (value) => {
        if (!value.includes("@")) return "Invalid email address";
        return null;
      },
    };
  }, []);
  const { values, errors, setFieldValue } = useForm({}, validators);
  const handleSubmit = useCallback(
    (evt) => {
      evt.preventDefault();
      console.log(values);
    },
    [values],
  );
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Name: </label>
        <input
          value={values.name || null}
          onChange={(evt) => setFieldValue("name", evt.target.value)}
        />
        {errors.name && <span style={{ color: "red" }}>{errors.name}</span>}
      </div>

      <div>
        <label>Email:</label>
        <input
          value={values.email || null}
          onChange={(evt) => setFieldValue("email", evt.target.value)}
        />
        {errors.email && <span style={{ color: "red" }}>{errors.email}</span>}
      </div>
      <button type="submit">Submit</button>
    </form>
  );
};


```

*   hooks 之定时器的开启和关闭

> start 方法可以开启定时器, clean 方法可以清除定时器

```php
import { useEffect, useRef, useLayoutEffect, useCallback } from 'react';

function useInterval(fn: Function, time: number) {
  const ref = useRef(fn);
  const timerRef = useRef(null);
  const timerCancelRef = useRef(false);
  useLayoutEffect(() => {
    ref.current = fn;
  });
  let cleanUpFnRef = useRef<Function>();
  const clean = useCallback(() => {
    cleanUpFnRef.current?.();
  }, []);

  const start = useCallback(() => {
    if (!timerCancelRef.current) {
      return;
    }
    const timer = setInterval(() => ref.current(), time);
    timerRef.current = timer;
    timerCancelRef.current = false;
  }, []);

  useEffect(() => {
    const timer = setInterval(() => ref.current(), time);
    timerRef.current = timer;
    cleanUpFnRef.current = () => {
      clearInterval(timerRef?.current);
      timerCancelRef.current = true;
    };
    return clean;
  }, []);
  return {
    clean,
    start,
  };
}

export default useInterval;
```

*   TS 之高阶组件

```php
const hoc = (wrapperComponentMap: Record<string|number, ComponentType<any>>): any => {
    function CreateView(props: IProps) {
        const RealComponent = wrapperComponentMap[props.type];
        return <RealComponent {...props} />
    }
    return CreateView;
}
```

