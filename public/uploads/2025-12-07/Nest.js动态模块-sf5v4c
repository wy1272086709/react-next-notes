#### &#x20;NestJs 动态模块

> 可以简单理解为通过函数生成的模块

##### &#x20;模块里面定义register方法或者registerAsync方法

```typescript
@Module({})
export class BbbModule {
  static register(options: Record<string, any>): DynamicModule {
    return {
      module: BbbModule,
      controllers: [BbbController],
      providers: [
        {
          provide: 'BBB_OPTIONS',
          useValue: options,
        },
        BbbService,
      ],
      exports: [],
    };
  }
}
....
app.module.ts 中的定义 
....
@Module({
  imports: [
    BbbModule.register({
      a: 1,
      b: 2,
    }),
  ]
})
```

##### &#x20;通过继承类的方式

```typescript
...在xx.module-definition.ts 文件中导出对应的类...
定义ConfigurableModuleClass 类，和MODULE_OPTIONS_TOKEN 常量
import { ConfigurableModuleBuilder } from '@nestjs/common';

export interface CccModuleOptions {
  aaa: number;
  bbb: string;
}

export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
  new ConfigurableModuleBuilder<CccModuleOptions>()
    .setClassMethodName('forRoot')
    .build();

... xxxModule 继承ConfigurableModuleClass 类
export class CccModule extends ConfigurableModuleClass {}

... 继承了ConfigurableModuleClass类之后，就可以使用`foorRoot`
@Module({
  imports: [
    CccModule.forRoot({
      aaa: 123,
      bbb: 'forRoot234',
    }),
    PersonModule,
  ]
});

... 可以通过MODULE_OPTIONS_TOKEN 获取传递过来的动态参数值
@Controller('ccc')
export class CccController {
  @Inject(MODULE_OPTIONS_TOKEN)
  private readonly options: CccModuleOptions;
}
```

